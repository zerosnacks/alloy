<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generate types that implement `alloy-sol-types` traits, which can be used for type-safe ABI and EIP-712 serialization to interface with Ethereum smart contracts."><title>sol in alloy::sol_types - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-b21aa549bf6d91ff.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="alloy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (1fffb2a35 2024-04-28)" data-channel="nightly" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-e32f0c247825364d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/alloy-rs/core/main/assets/favicon.ico"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../alloy/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../alloy/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><h2><a href="../../alloy/index.html">alloy</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In alloy::sol_types</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../alloy/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="../index.html">alloy</a>::<wbr><a href="index.html">sol_types</a>::<wbr><a class="macro" href="#">sol</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>sol!() { <span class="comment">/* proc-macro */</span> }</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>sol-types</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generate types that implement <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a> traits, which can be used
for type-safe <a href="https://docs.soliditylang.org/en/latest/abi-spec.html">ABI</a> and <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a> serialization to interface with Ethereum
smart contracts.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<blockquote>
<p>Note: the following example code blocks cannot be tested here because the
generated code references <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a>, so they are <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types/tests/doctests">tested in that
crate</a> and included with [<code>include_str!</code>] in this doc instead.</p>
</blockquote>
<p>There are two main ways to use this macro:</p>
<ul>
<li>you can <a href="#solidity">write Solidity code</a>, or provide a path to a Solidity file,</li>
<li>if you enable the <code>json</code> feature, you can provide <a href="#json-abi">an ABI, or a path to one, in JSON
format</a>.</li>
</ul>
<p>Note:</p>
<ul>
<li>relative file system paths are rooted at the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
<li>no casing convention is enforced for any identifier,</li>
<li>unnamed arguments will be given a name based on their index in the list, e.g. <code>_0</code>, <code>_1</code>…</li>
<li>a current limitation for certain items is that custom types, like structs, must be defined in
the same macro scope, otherwise a signature cannot be generated at compile time. You can bring
them in scope with a <a href="#udvt-and-type-aliases">Solidity type alias</a>.</li>
</ul>
<h3 id="solidity"><a class="doc-anchor" href="#solidity">§</a>Solidity</h3>
<p>This macro uses [<code>syn-solidity</code>][ast] to parse Solidity-like syntax. See
[its documentation][ast] for more.</p>
<p>Solidity input can be either one of the following:</p>
<ul>
<li>a Solidity item, which is a <a href="https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.sourceUnit">Solidity source unit</a> which generates one or more Rust
items,</li>
<li>a <a href="https://docs.soliditylang.org/en/latest/types.html">Solidity type name</a>, which simply expands to the corresponding Rust type.</li>
</ul>
<p><strong>IMPORTANT!</strong> This is <strong>NOT</strong> a Solidity compiler, or a substitute for one! It only parses a
Solidity-like syntax to generate Rust types, designed for simple interfaces defined inline with
your other Rust code.</p>
<p>Further, this macro does not resolve imports or dependencies, and it does not handle
inheritance. All required types must be provided in the same macro scope.</p>
<h4 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h4>
<p>Inner attributes (<code>#![...]</code>) are parsed at the top of the input, just like a
Rust module. These can only be <code>sol</code> attributes, and they will apply to the
entire input.</p>
<p>Outer attributes (<code>#[...]</code>) are parsed as part of each individual item, like
structs, enums, etc. These can be any Rust attribute, and they will be added
to every Rust item generated from the Solidity item.</p>
<p>This macro provides the <code>sol</code> attribute, which can be used to customize the
generated code. Note that unused attributes are currently silently ignored,
but this may change in the future.</p>
<p>Note that the <code>sol</code> attribute does not compose like other Rust attributes, for example
<code>#[cfg_attr]</code> will <strong>NOT</strong> work, as it is parsed and extracted from the input separately.
This is a limitation of the proc-macro API.</p>
<p>List of all <code>#[sol(...)]</code> supported values:</p>
<ul>
<li>
<p><code>rpc [ = &lt;bool = false&gt;]</code> (contracts and alike only): generates a structs with methods to
construct <code>eth_call</code>s to an on-chain contract through Ethereum JSON RPC, similar to the
default behavior of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a>. This makes use of the <a href="https://github.com/alloy-rs/alloy"><code>alloy-contract</code></a>
crate.</p>
<p>N.B: at the time of writing, the <code>alloy-contract</code> crate is not yet released on <code>crates.io</code>,
and its API is completely unstable and subject to change, so this feature is not yet
recommended for use.</p>
<p>Generates the following items inside of the <code>{name}</code> module:</p>
<ul>
<li><code>struct {name}Instance&lt;P: Provider&gt; { ... }</code>
<ul>
<li><code>pub fn new(...) -&gt; {name}Instance&lt;P&gt;</code> + getters and setters</li>
<li><code>pub fn call_builder&lt;C: SolCall&gt;(&amp;self, call: &amp;C) -&gt; SolCallBuilder&lt;P, C&gt;</code>, as a generic
way to call any function of the contract, even if not generated by the macro; prefer the
other methods when possible</li>
<li><code>pub fn &lt;functionName&gt;(&amp;self, &lt;parameters&gt;...) -&gt; CallBuilder&lt;P, functionReturn&gt;</code> for each
function in the contract</li>
<li><code>pub fn &lt;eventName&gt;_filter(&amp;self) -&gt; Event&lt;P, eventName&gt;</code> for each event in the contract</li>
</ul>
</li>
<li><code>pub fn new ...</code>, same as above just as a free function in the contract module</li>
</ul>
</li>
<li>
<p><code>abi [ = &lt;bool = false&gt;]</code>: generates functions which return the dynamic ABI representation
(provided by <a href="https://docs.rs/alloy-json-abi"><code>alloy_json_abi</code></a>) of all the generated items.
Requires the <code>&quot;json&quot;</code> feature. For:</p>
<ul>
<li>contracts: generates an <code>abi</code> module nested inside of the contract module, which contains:
<ul>
<li><code>pub fn contract() -&gt; JsonAbi</code>,</li>
<li><code>pub fn constructor() -&gt; Option&lt;Constructor&gt;</code></li>
<li><code>pub fn fallback() -&gt; Option&lt;Fallback&gt;</code></li>
<li><code>pub fn receive() -&gt; Option&lt;Receive&gt;</code></li>
<li><code>pub fn functions() -&gt; BTreeMap&lt;String, Vec&lt;Function&gt;&gt;</code></li>
<li><code>pub fn events() -&gt; BTreeMap&lt;String, Vec&lt;Event&gt;&gt;</code></li>
<li><code>pub fn errors() -&gt; BTreeMap&lt;String, Vec&lt;Error&gt;&gt;</code></li>
</ul>
</li>
<li>items: generates implementations of the <code>SolAbiExt</code> trait, alongside the existing
<a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a> traits</li>
</ul>
</li>
<li>
<p><code>alloy_sol_types = &lt;path = ::alloy_sol_types&gt;</code> (inner attribute only): specifies the path to
the required dependency <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a>.</p>
</li>
<li>
<p><code>alloy_contract = &lt;path = ::alloy_contract&gt;</code> (inner attribute only): specifies the path to the
optional dependency [<code>alloy-contract</code>]. This is only used in combination with the <code>rpc</code>
attribute.</p>
</li>
<li>
<p><code>all_derives [ = &lt;bool = false&gt;]</code>: adds all possible <code>#[derive(...)]</code> attributes to all
generated types. May significantly increase compile times due to all the extra generated code.
This is the default behavior of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></p>
</li>
<li>
<p><code>extra_methods [ = &lt;bool = false&gt;]</code>: adds extra implementations and methods to all applicable
generated types, such as <code>From</code> impls and <code>as_&lt;variant&gt;</code> methods. May significantly increase
compile times due to all the extra generated code. This is the default behavior of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></p>
</li>
<li>
<p><code>docs [ = &lt;bool = true&gt;]</code>: adds doc comments to all generated types. This is the default
behavior of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></p>
</li>
<li>
<p><code>bytecode = &lt;hex string literal&gt;</code> (contract-like only): specifies the creation/init bytecode
of a contract. This will emit a <code>static</code> item with the specified bytes.</p>
</li>
<li>
<p><code>deployed_bytecode = &lt;hex string literal&gt;</code> (contract-like only): specifies the deployed
bytecode of a contract. This will emit a <code>static</code> item with the specified bytes.</p>
</li>
<li>
<p><code>type_check = &lt;string literal&gt;</code> (UDVT only): specifies a function to be used to check an User
Defined Type.</p>
</li>
</ul>
<h4 id="structs-and-enums"><a class="doc-anchor" href="#structs-and-enums">§</a>Structs and enums</h4>
<p>Structs and enums generate their corresponding Rust types. Enums are
additionally annotated with <code>#[repr(u8)]</code>, and as such can have a maximum of
256 variants.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
<h4 id="udvt-and-type-aliases"><a class="doc-anchor" href="#udvt-and-type-aliases">§</a>UDVT and type aliases</h4>
<p>User defined value types (UDVT) generate a tuple struct with the type as
its only field, and type aliases simply expand to the corresponding Rust
type.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
<h4 id="state-variables"><a class="doc-anchor" href="#state-variables">§</a>State variables</h4>
<p>Public and external state variables will generate a getter function just like in Solidity.</p>
<p>See the <a href="#functions-and-errors">functions</a> and <a href="#contractsinterfaces">contracts</a>
sections for more information.</p>
<h4 id="functions-and-errors"><a class="doc-anchor" href="#functions-and-errors">§</a>Functions and errors</h4>
<p>Functions generate two structs that implement <code>SolCall</code>: <code>&lt;name&gt;Call</code> for
the function arguments, and <code>&lt;name&gt;Return</code> for the return values.</p>
<p>In the case of overloaded functions, an underscore and the index of the
function will be appended to <code>&lt;name&gt;</code> (like <code>foo_0</code>, <code>foo_1</code>…) for
disambiguation, but the signature will remain the same.</p>
<p>E.g. if there are two functions named <code>foo</code>, the generated types will be
<code>foo_0Call</code> and <code>foo_1Call</code>, each of which will implement <code>SolCall</code>
with their respective signatures.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
<h4 id="events"><a class="doc-anchor" href="#events">§</a>Events</h4>
<p>Events generate a struct that implements <code>SolEvent</code>.</p>
<p>Note that events have special encoding rules in Solidity. For example,
<code>string indexed</code> will be encoded in the topics as its <code>bytes32</code> Keccak-256
hash, and as such the generated field for this argument will be <code>bytes32</code>,
and not <code>string</code>.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
<h4 id="contractsinterfaces"><a class="doc-anchor" href="#contractsinterfaces">§</a>Contracts/interfaces</h4>
<p>Contracts generate a module with the same name, which contains all the items.
This module will also contain 3 container enums which implement <code>SolInterface</code>, one for each:</p>
<ul>
<li>functions: <code>&lt;contract_name&gt;Calls</code></li>
<li>errors: <code>&lt;contract_name&gt;Errors</code></li>
<li>events: <code>&lt;contract_name&gt;Events</code>
Note that by default only ABI encoding are generated. In order to generate bindings for RPC
calls, you must enable the <code>#[sol(rpc)]</code> attribute.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
<h3 id="json-abi"><a class="doc-anchor" href="#json-abi">§</a>JSON ABI</h3>
<p>Contracts can also be generated from ABI JSON strings and files, similar to
the <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html">ethers-rs <code>abigen!</code> macro</a>.</p>
<p>JSON objects containing the <code>abi</code>, <code>evm</code>, <code>bytecode</code>, <code>deployedBytecode</code>,
and similar keys are also supported.</p>
<p>Note that only valid JSON is supported, and not the human-readable ABI
format, also used by <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen!</code></a>. This should instead be easily converted to
<a href="#solidity">normal Solidity input</a>.</p>
<p>Prefer using <a href="#solidity">Solidity input</a> when possible, as the JSON ABI
format omits some information which is useful to this macro, such as enum
variants and visibility modifiers on functions.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code></code></pre></div>
</div></details></section></div></main></body></html>